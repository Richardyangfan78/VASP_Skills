"""POSCAR file reading, writing, and manipulation."""

import re
import numpy as np
from typing import List, Optional, Tuple
from pathlib import Path


class Poscar:
    """POSCAR/CONTCAR file handler.

    Attributes:
        comment: Comment line (first line).
        scale: Universal scaling factor.
        lattice: 3x3 numpy array of lattice vectors (rows).
        species: List of element symbols, e.g. ["Si", "O"].
        counts: List of atom counts per species, e.g. [2, 4].
        selective_dynamics: Whether selective dynamics is enabled.
        cartesian: True for Cartesian, False for Direct coordinates.
        positions: Nx3 numpy array of atomic positions.
        sd_flags: Nx3 array of 'T'/'F' strings (or None).
    """

    def __init__(
        self,
        lattice: np.ndarray,
        species: List[str],
        counts: List[int],
        positions: np.ndarray,
        comment: str = "Generated by VASP Skills",
        scale: float = 1.0,
        cartesian: bool = False,
        selective_dynamics: bool = False,
        sd_flags: Optional[np.ndarray] = None,
    ):
        self.comment = comment
        self.scale = scale
        self.lattice = np.array(lattice, dtype=float)
        self.species = list(species)
        self.counts = list(counts)
        self.positions = np.array(positions, dtype=float)
        self.cartesian = cartesian
        self.selective_dynamics = selective_dynamics
        self.sd_flags = sd_flags

    @property
    def natoms(self) -> int:
        return sum(self.counts)

    @property
    def elements(self) -> List[str]:
        """Expanded list of element for each atom."""
        elems = []
        for sp, cnt in zip(self.species, self.counts):
            elems.extend([sp] * cnt)
        return elems

    @property
    def volume(self) -> float:
        """Cell volume in Angstrom^3."""
        return abs(np.linalg.det(self.lattice)) * self.scale ** 3

    def to_cartesian(self) -> np.ndarray:
        """Return positions in Cartesian coordinates."""
        if self.cartesian:
            return self.positions * self.scale
        return self.positions @ (self.lattice * self.scale)

    def to_direct(self) -> np.ndarray:
        """Return positions in fractional/direct coordinates."""
        if not self.cartesian:
            return self.positions.copy()
        inv_lat = np.linalg.inv(self.lattice * self.scale)
        return self.positions @ inv_lat

    def to_string(self) -> str:
        """Generate POSCAR file content."""
        lines = [self.comment]
        lines.append(f"  {self.scale:.10f}")

        for vec in self.lattice:
            lines.append(f"  {vec[0]:20.14f}  {vec[1]:20.14f}  {vec[2]:20.14f}")

        lines.append("  " + "  ".join(self.species))
        lines.append("  " + "  ".join(str(c) for c in self.counts))

        if self.selective_dynamics:
            lines.append("Selective dynamics")

        lines.append("Cartesian" if self.cartesian else "Direct")

        for i, pos in enumerate(self.positions):
            line = f"  {pos[0]:20.14f}  {pos[1]:20.14f}  {pos[2]:20.14f}"
            if self.selective_dynamics and self.sd_flags is not None:
                line += f"  {self.sd_flags[i][0]}  {self.sd_flags[i][1]}  {self.sd_flags[i][2]}"
            lines.append(line)

        return "\n".join(lines) + "\n"

    def write(self, filepath: str = "POSCAR"):
        """Write POSCAR to file."""
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, "w") as f:
            f.write(self.to_string())

    @classmethod
    def read(cls, filepath: str = "POSCAR") -> "Poscar":
        """Read a POSCAR/CONTCAR file."""
        with open(filepath) as f:
            lines = f.readlines()

        comment = lines[0].strip()
        scale = float(lines[1].strip())
        lattice = np.array(
            [[float(x) for x in lines[i].split()] for i in range(2, 5)]
        )

        # Line 5 might be species or counts (VASP4 vs VASP5)
        line5 = lines[5].split()
        try:
            counts = [int(x) for x in line5]
            species = []  # VASP4 format, no species line
            count_line = 5
        except ValueError:
            species = line5
            counts = [int(x) for x in lines[6].split()]
            count_line = 6

        natoms = sum(counts)
        next_line = count_line + 1

        # Check for Selective dynamics
        selective_dynamics = False
        coord_line = lines[next_line].strip()
        if coord_line[0].upper() == "S":
            selective_dynamics = True
            next_line += 1
            coord_line = lines[next_line].strip()

        cartesian = coord_line[0].upper() in ("C", "K")
        next_line += 1

        positions = []
        sd_flags = [] if selective_dynamics else None

        for i in range(natoms):
            parts = lines[next_line + i].split()
            positions.append([float(parts[0]), float(parts[1]), float(parts[2])])
            if selective_dynamics:
                if len(parts) >= 6:
                    sd_flags.append([parts[3], parts[4], parts[5]])
                else:
                    sd_flags.append(["T", "T", "T"])

        positions = np.array(positions)
        if sd_flags is not None:
            sd_flags = np.array(sd_flags)

        return cls(
            lattice=lattice,
            species=species,
            counts=counts,
            positions=positions,
            comment=comment,
            scale=scale,
            cartesian=cartesian,
            selective_dynamics=selective_dynamics,
            sd_flags=sd_flags,
        )

    @classmethod
    def from_cif(cls, filepath: str) -> "Poscar":
        """Read structure from a CIF file (requires pymatgen)."""
        try:
            from pymatgen.core import Structure as PMGStructure
            struct = PMGStructure.from_file(filepath)
            species = []
            counts = []
            for el in struct.composition.elements:
                species.append(str(el))
                counts.append(int(struct.composition[el]))
            return cls(
                lattice=struct.lattice.matrix,
                species=species,
                counts=counts,
                positions=struct.frac_coords,
                comment=f"From CIF: {Path(filepath).name}",
                cartesian=False,
            )
        except ImportError:
            raise ImportError(
                "pymatgen is required for CIF import. "
                "Install with: pip install pymatgen"
            )

    def make_supercell(self, scaling: Tuple[int, int, int]) -> "Poscar":
        """Create a supercell by replicating the unit cell."""
        sa, sb, sc = scaling
        new_lattice = self.lattice.copy()
        new_lattice[0] *= sa
        new_lattice[1] *= sb
        new_lattice[2] *= sc

        frac = self.to_direct()
        new_positions = []
        new_sd = [] if self.selective_dynamics else None

        for ia in range(sa):
            for ib in range(sb):
                for ic in range(sc):
                    shift = np.array([ia / sa, ib / sb, ic / sc])
                    for idx in range(self.natoms):
                        new_positions.append(frac[idx] / np.array([sa, sb, sc]) + shift)
                        if self.selective_dynamics and self.sd_flags is not None:
                            new_sd.append(self.sd_flags[idx])

        new_counts = [c * sa * sb * sc for c in self.counts]

        return Poscar(
            lattice=new_lattice,
            species=self.species,
            counts=new_counts,
            positions=np.array(new_positions),
            comment=f"{self.comment} - {sa}x{sb}x{sc} supercell",
            cartesian=False,
            selective_dynamics=self.selective_dynamics,
            sd_flags=np.array(new_sd) if new_sd else None,
        )

    def sort_by_species(self) -> "Poscar":
        """Sort atoms by species alphabetically."""
        elements = self.elements
        frac = self.to_direct()

        indices = sorted(range(self.natoms), key=lambda i: elements[i])
        sorted_elems = [elements[i] for i in indices]
        sorted_pos = frac[indices]
        sorted_sd = self.sd_flags[indices] if self.sd_flags is not None else None

        # Rebuild species and counts
        species = []
        counts = []
        for el in sorted_elems:
            if not species or species[-1] != el:
                species.append(el)
                counts.append(1)
            else:
                counts[-1] += 1

        return Poscar(
            lattice=self.lattice.copy(),
            species=species,
            counts=counts,
            positions=sorted_pos,
            comment=self.comment,
            scale=self.scale,
            cartesian=False,
            selective_dynamics=self.selective_dynamics,
            sd_flags=sorted_sd,
        )

    def __repr__(self) -> str:
        formula = " ".join(f"{s}{c}" for s, c in zip(self.species, self.counts))
        return f"Poscar({formula}, {self.natoms} atoms)"
