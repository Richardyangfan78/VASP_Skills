"""KPOINTS file generation with multiple modes."""

import numpy as np
from typing import List, Optional, Tuple
from pathlib import Path


class Kpoints:
    """KPOINTS file generator supporting multiple meshing modes.

    Modes:
        - Monkhorst-Pack (MP) grid
        - Gamma-centered grid
        - Automatic (density-based)
        - Line mode (for band structures)
        - Explicit k-points
    """

    def __init__(self):
        self._content: str = ""
        self.comment: str = "Auto-generated by VASP Skills"

    @classmethod
    def monkhorst_pack(
        cls, grid: Tuple[int, int, int], shift: Tuple[float, float, float] = (0, 0, 0)
    ) -> "Kpoints":
        """Create Monkhorst-Pack k-point mesh."""
        kp = cls()
        kp.comment = f"Monkhorst-Pack {grid[0]}x{grid[1]}x{grid[2]}"
        lines = [
            kp.comment,
            "0",
            "Monkhorst-Pack",
            f"  {grid[0]}  {grid[1]}  {grid[2]}",
            f"  {shift[0]}  {shift[1]}  {shift[2]}",
        ]
        kp._content = "\n".join(lines) + "\n"
        return kp

    @classmethod
    def gamma_centered(
        cls, grid: Tuple[int, int, int], shift: Tuple[float, float, float] = (0, 0, 0)
    ) -> "Kpoints":
        """Create Gamma-centered k-point mesh."""
        kp = cls()
        kp.comment = f"Gamma {grid[0]}x{grid[1]}x{grid[2]}"
        lines = [
            kp.comment,
            "0",
            "Gamma",
            f"  {grid[0]}  {grid[1]}  {grid[2]}",
            f"  {shift[0]}  {shift[1]}  {shift[2]}",
        ]
        kp._content = "\n".join(lines) + "\n"
        return kp

    @classmethod
    def gamma_only(cls) -> "Kpoints":
        """Gamma-point only calculation."""
        return cls.gamma_centered((1, 1, 1))

    @classmethod
    def automatic(cls, length: int = 40) -> "Kpoints":
        """Automatic k-mesh with specified length parameter (KSPACING-like)."""
        kp = cls()
        kp.comment = f"Automatic mesh (length={length})"
        lines = [
            kp.comment,
            "0",
            "Auto",
            f"  {length}",
        ]
        kp._content = "\n".join(lines) + "\n"
        return kp

    @classmethod
    def from_density(
        cls,
        lattice: np.ndarray,
        density: float = 40.0,
        force_gamma: bool = True,
    ) -> "Kpoints":
        """Generate k-mesh from reciprocal space density (points per inv-Angstrom).

        Args:
            lattice: 3x3 lattice matrix (rows are vectors).
            density: K-point density per reciprocal angstrom.
            force_gamma: Use Gamma-centered mesh.
        """
        rec_lengths = np.linalg.norm(
            np.cross(lattice[[1, 2, 0]], lattice[[2, 0, 1]]), axis=1
        )
        volume = abs(np.linalg.det(lattice))
        rec_lengths = 2 * np.pi * rec_lengths / volume

        grid = tuple(max(1, int(np.ceil(density * rl))) for rl in rec_lengths)

        if force_gamma:
            return cls.gamma_centered(grid)
        return cls.monkhorst_pack(grid)

    @classmethod
    def line_mode(
        cls,
        kpath: List[Tuple[str, List[float]]],
        num_points: int = 40,
    ) -> "Kpoints":
        """Create line-mode KPOINTS for band structure.

        Args:
            kpath: List of (label, [kx, ky, kz]) tuples defining the path.
                   Consecutive pairs define line segments.
            num_points: Points per segment.

        Example:
            kpath = [
                ("G", [0, 0, 0]), ("X", [0.5, 0, 0]),
                ("X", [0.5, 0, 0]), ("M", [0.5, 0.5, 0]),
                ("M", [0.5, 0.5, 0]), ("G", [0, 0, 0]),
            ]
        """
        kp = cls()
        kp.comment = "Band structure path"
        lines = [kp.comment, str(num_points), "Line-mode", "Reciprocal"]

        for label, coords in kpath:
            lines.append(
                f"  {coords[0]:.8f}  {coords[1]:.8f}  {coords[2]:.8f}  ! {label}"
            )

        kp._content = "\n".join(lines) + "\n"
        return kp

    @classmethod
    def line_mode_auto(cls, structure_or_poscar, num_points: int = 40) -> "Kpoints":
        """Auto-generate band path from structure using pymatgen.

        Args:
            structure_or_poscar: Poscar object or pymatgen Structure.
            num_points: Points per segment.
        """
        try:
            from pymatgen.core import Structure as PMGStructure
            from pymatgen.symmetry.bandstructure import HighSymmKpath

            # Convert Poscar to pymatgen Structure if needed
            if hasattr(structure_or_poscar, "lattice") and hasattr(
                structure_or_poscar, "species"
            ):
                poscar = structure_or_poscar
                struct = PMGStructure(
                    lattice=poscar.lattice * poscar.scale,
                    species=poscar.elements,
                    coords=poscar.to_direct(),
                )
            else:
                struct = structure_or_poscar

            kpath_obj = HighSymmKpath(struct)
            kpath_dict = kpath_obj.kpath
            kpts = kpath_dict["kpoints"]

            path_pairs = []
            for path_segment in kpath_dict["path"]:
                for i in range(len(path_segment) - 1):
                    label1 = path_segment[i]
                    label2 = path_segment[i + 1]
                    path_pairs.append((label1, list(kpts[label1])))
                    path_pairs.append((label2, list(kpts[label2])))

            return cls.line_mode(path_pairs, num_points)
        except ImportError:
            raise ImportError(
                "pymatgen is required for automatic band path. "
                "Install with: pip install pymatgen"
            )

    @classmethod
    def explicit(
        cls,
        kpoints: List[List[float]],
        weights: Optional[List[float]] = None,
        labels: Optional[List[str]] = None,
        reciprocal: bool = True,
    ) -> "Kpoints":
        """Write explicit k-point list."""
        kp = cls()
        nk = len(kpoints)
        if weights is None:
            weights = [1.0] * nk

        kp.comment = f"Explicit k-points ({nk})"
        coord_type = "Reciprocal" if reciprocal else "Cartesian"
        lines = [kp.comment, str(nk), coord_type]

        for i, (k, w) in enumerate(zip(kpoints, weights)):
            line = f"  {k[0]:.8f}  {k[1]:.8f}  {k[2]:.8f}  {w:.4f}"
            if labels and i < len(labels):
                line += f"  ! {labels[i]}"
            lines.append(line)

        kp._content = "\n".join(lines) + "\n"
        return kp

    def to_string(self) -> str:
        return self._content

    def write(self, filepath: str = "KPOINTS"):
        """Write KPOINTS file to disk."""
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, "w") as f:
            f.write(self._content)

    @classmethod
    def read(cls, filepath: str = "KPOINTS") -> "Kpoints":
        """Read an existing KPOINTS file."""
        kp = cls()
        with open(filepath) as f:
            kp._content = f.read()
        kp.comment = kp._content.split("\n")[0] if kp._content else ""
        return kp

    def __repr__(self) -> str:
        return f"Kpoints({self.comment})"
